"FUNCTIONS"


**01.and*.py**

Напишите функцию get_unique(), которая принимает произвольное количество списков и возвращает список, содержащий все элементы из всех списков, но без повторений.

get_unique([1, 2, 3], [3, 4, 5], [5, 6, 7])  # [1, 2, 3, 4, 5, 6, 7]


**02.higher_order_functions.py**

Вам предстоит реализовать пару функций:

Функцию-ключ get_first_name(), которая получает имя пользователя из строки вида "Имя_Фамилия"
get_first_name("Vader_Darth")  # Vader
Функцию сортировки sort_by(), которая принимает функцию-ключ и список и сортирует список по этому ключу. Функция не должна изменять оригинальный список.
users = ["Vader_Darth", "Luke_Skywalker", "Boba_Fett"]
 
sort_by(get_first_name, users)  # ["Boba_Fett", "Luke_Skywalker", "Vader_Darth"]
print(users) # => ["Vader_Darth", "Luke_Skywalker", "Boba_Fett"] 
Подсказки
Для сортировки используйте встроенную функцию sorted()


**03.map,filter.py**

Реализуйте функцию filter_map(), которая ведёт себя подобно filter() и map(), работающим вместе. filter_map() должна принимать в качестве аргументов функцию и итерируемый источник, а возвращать должна список. Данная функция не должна использовать функции filter() и map(), а только воспроизводить логику, похожую на указанные функции.

В теле filter_map() к каждому значению из источника нужно применять функцию, которая в ответ будет возвращать пару:

Булево значение,
Некий результат.
Если булево значение (1) истинно, то результат (2) должен попадать в результирующий список. В противном случае второе значение пары игнорируется.

def make_stars(x):
    if x > 0:Реализуйте функцию, которая проверяет переданное число на простоту и печатает на экран yes или no.

Примеры
say_prime_or_not(5) ## yes
say_prime_or_not(4) ## no
Подсказки
Цель этой задачи — научиться отделять чистый код от кода с побочными эффектами.

Для этого выделите процесс определения того, является ли число простым, в отдельную функцию, возвращающую логическое значение. Это функция, с помощью которой мы отделяем чистый код от кода, интерпретирующего логическое значение (как 'yes' или 'no') и делающего побочный эффект (печать на экран).

Пример такого разделения и хороших абстракций — в решении учителя.
        return True, '*' * x
    return False, ''
 
for s in filter_map(make_stars, [1, 0, 5, -5, 2]):
    print(s)
# => *
# => *****
# => **


**04.pure_func.py**

Реализуйте функцию, которая проверяет переданное число на простоту и печатает на экран yes или no.

Примеры
say_prime_or_not(5) ## yes
say_prime_or_not(4) ## no
Подсказки
Цель этой задачи — научиться отделять чистый код от кода с побочными эффектами.

Для этого выделите процесс определения того, является ли число простым, в отдельную функцию, возвращающую логическое значение. Это функция, с помощью которой мы отделяем чистый код от кода, интерпретирующего логическое значение (как 'yes' или 'no') и делающего побочный эффект (печать на экран).

Пример такого разделения и хороших абстракций — в решении учителя.


**05.fvp.py**

В этом упражнении вам предстоит попрактиковаться в использовании встроенных функций map(), filter(), reduce() (эту нужно импортировать из functools). На их основе вам нужно реализовать три функции: keep_truthful(), abs_sum() и walk().

Функция keep_truthful() должна принимать на вход итерируемый источник значений и возвращать итератор, отдающий только те значения из источника, которые "истинны" (вам пригодится функция operator.truth).

list(keep_truthful([True, False, "", "foo"]))
# [True, 'foo']
Функция abs_sum() принимает на вход итерируемый источник чисел. Вернуть же функция должна сумму абсолютных значений этих чисел (используйте sum и abs).

abs_sum([-3, 7])
# 10
abs_sum([])
# 0
abs_sum([42])
# 42
walk() должна для некоего словаря с глубокой вложенностью уметь доставать значение по указанному в виде iterable строк пути. В решении можете использовать функцию operator.getitem.

Имейте в виду: мы считаем, что значения по указанному пути всегда доступны и сама структура словаря всегда правильная. Это означает, что заранее обрабатывать ошибки не нужно. Так что реализуйте "оптимистичное решение".

walk({'a': {7: {'b': 42}}}, ["a", 7, "b"])
# 42
walk({'a': {7: {'b': 42}}}, ["a", 7])
# {'b': 42}


**06.closure.py**

В этом упражнении вам нужно будет реализовать две функции высшего порядка, возвращающие замыкания: partial_apply() и flip().

partial_apply() принимает функцию от двух аргументов и первый аргумент для неё, а возвращает замыкание — функцию, которая примет второй аргумент и наконец применит замкнутую функцию к обоим аргументам (и вернёт результат).

def greet(name, surname):
    return f'Hello, {name} {surname}!'
 
f = partial_apply(greet, 'Dorian')
f('Grey')
# 'Hello, Dorian Grey!'
Функция flip() принимает в качестве единственного аргумента функцию от двух аргументов. Возвращаемое замыкание должно также принять два аргумента, а затем применить к ним замкнутую функцию, но аргументы подставить в обратном порядке. Таким образом flip() как бы "переворачивает" ("flips") исходную функцию.

def greet(name, surname):
    return f'Hello, {name} {surname}!'
 
f = flip(greet)
f('Christian', 'Teodor')
# 'Hello, Teodor Christian!'


**07.lambda_func.py**

Реализуйте функцию make_module() так, чтобы она

принимала аргумент step со значением по умолчанию равным 1,
возвращала словарь с ключами "inc" (от "увеличить"/"increment") и "dec" (от "уменьшить"/"decrement"), по которым можно было бы получить лямбды, одна из которых добавляет, а вторая вычитает step из своего аргумента.
Тело функции make_module() должно состоять из одного выражения — return {…}. То есть лямбда-функции должны быть объявлены прямо в литерале словаря!

m = make_module()
m['inc'](10)
# 11
m['dec'](20)
# 19
m2 = make_module(step=2)
m2['inc'](1)
# 3


**08.decorator.py**

Вам предстоит реализовать декоратор, добавляющий функции мемоизацию. Мемоизация — это запоминание уже вычисленных результатов для уже однажды встреченных аргументов.

Для простоты будем считать, что мемоизироваться будут численные функции одного аргумента (аргумент — число, результат — тоже число). Полученный результат должен возвращаться.

from solution import memoized
@memoized
def f(x):
    print('Calculating...')
    return x * 10
 
f(1)
# => Calculating...
# 10
f(1)
# 10
f(42)
# => Calculating...
# 420
f(42)
# 420
f(1)
# 10
Заметьте, что для каждого нового аргумента выводится сообщение "Calculating...", но только лишь один раз.

**09.decor+arg.py**

В этот раз вы снова будете реализовывать мемоизирующий декоратор "memoizing". Но на этот раз декоратор должен принимать аргумент, задающий максимальное количество запоминаемых значений. При превышении количества запомненных значений лишние должны быть отброшены, причём сначала — самые старые!

Напоминаю, мемоизируемые функции считать численными функциями одного аргумента. И не забудьте про functools.wraps!

@memoizing(3)
def f(x):
    print('Calculating...')
    return x * 10
 
f(1)
# => Calculating...
# 10
f(1)  # будет "вспомнено"
# 10
f(2)
# => Calculating...
# 20
f(3)
# => Calculating...
# 30
f(4)  # вытеснит запомненный результат для "1"
# => Calculating...
# 40
f(1)  # будет перевычислено
# => Calculating...
# 10
Подсказки
Хоть в современном Python словарь и помнит, в каком порядке добавлялись ключи, но я не рекомендую строить логику, опираясь на это свойство. Используйте вспомогательную структуру для хранения порядка ключей.


**10.recursion.py**

Привычные нам структуры можно представить и как рекурсивные. Например, у списка, есть голова (первый элемент) и хвост (последущие), у хвоста тоже есть своя голова и хвост, который тоже можно разделить на голову и хвост. И так далее до конца, где последний элемент списка можно представить как голова плюс хвост из пустого списка. А вот уже пустой список невозможно разделить, и наша рекурсия остановится.

[1, 2, 3] # голова [1], хвост [2, 3]
[2, 3] # голова [2], хвост [3]
[3] # голова [3], хвост пустой список []
[] # остановка
В этом упражнении вам нужно будет реализовать три несложные функции, но через рекурсивный процесс:

length() принимает список и возвращает его длину
length([1, 2, 3]) # 3
reverse_range() принимает два числа begin и end и возвращает перевернутый список всех чисел между. Для простоты договоримся, что begin <= end
reverse_range(1, 1) # [1]
reverse_range(1, 3) # [3, 2, 1]
filter_positive() принимает список чисел и возвращает новый только с положительными элементами
filter_positive([]) # []
filter_positive([-3]) # []
filter_positive([1, -2, 3]) # [1, 3]
Вы, конечно, можете реализовать функции привычным итеративным способом, но попробуйте сменить угол зрения.

**11.bar_chart.py**

Реализуйте функцию, которая выводит на экран столбчатую диаграмму в виде строки. Функция принимает в качестве параметра последовательность чисел, длина которой равна количеству столбцов диаграммы. Размер диаграммы по вертикали должен определяться входными данными.

print(barchart([5, 10, -5, -3, 7]))
# =>  *   
#     *   
#     *   
#     *  *
#     *  *
#    **  *
#    **  *
#    **  *
#    **  *
#    **  *
#      ## 
#      ## 
#      ## 
#      #  
#      #  

print(barchart([5, -2, 10, 6, 1, 2, 6, 4, 8, 1, -1, 7, 3, -5, 5]))
# =>   *            
#      *            
#      *     *      
#      *     *  *   
#      **  * *  *   
#    * **  * *  *  *
#    * **  ***  *  *
#    * **  ***  ** *
#    * ** ****  ** *
#    * ******** ** *
#     #        #  # 
#     #           # 
#                 # 
#                 # 
#                 # 


**12.IPv6_valid.py**

Реализуйте функцию-предикат is_valid_ipv6(), которая проверяет IPv6-адреса (адреса шестой версии интернет протокола) на корректность. Функция принимает на вход строку с адресом IPv6 и возвращает True, если адрес корректный, и False, если нет.

Дополнительные условия:

Работа функции не зависит от регистра символов.
Ведущие нули в группах цифр необязательны.
Самая длинная последовательность групп нулей, например, :0:0:0: может быть заменена на два двоеточия ::. Такую замену можно произвести только один раз.
from solution import is_valid_ipv6
is_valid_ipv6('10:d3:2d06:24:400c:5ee0:be:3d')
# True
is_valid_ipv6('::1')
# True
is_valid_ipv6('2607:G8B0:4010:801::1004')
# False
is_valid_ipv6('2.001::')
# False
Подсказки
IPv6
Для реализации проверки пограничных случаев изучите список IP-адресов в модуле с тестами
Используйте константу string.hexdigits для проверки, что строка содержит валидное представление шестнадцатеричного числа


