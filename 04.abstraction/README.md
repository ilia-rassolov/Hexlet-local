"ABSTRACTION"

**a_calculate_distance.py**

Реализуйте функцию calculate_distance(), которая находит расстояние между двумя точками на плоскости:

point1 = [0, 0]
point2 = [3, 4]
calculate_distance(point1, point2)  # 5.0
Подсказки
Расстояние между точками вычисляется по формуле: d = √((x₂−x₁)²+(y₂−y₁)²)
Объяснение формулы расчёта расстояния между двумя точками



**b_midpoint.py**

Реализуйте функцию, которая находит точку посередине между двумя указанными точками:

Пример работы:

point1 = {'x': 0, 'y': 0}
point2 = {'x': 4, 'y': 4}
get_mid_point(point1, point2)  # {'x': 2, 'y': 2}
Подсказки
Средняя точка вычисляется по формуле x = (x1 + x2) / 2 и y = (y1 + y2) / 2.

**c_make_abstraction.py**

Реализуйте указанные ниже функции:

make_segment() — принимает на вход две точки и возвращает отрезок
get_mid_point_of_segment() — принимает на вход отрезок и возвращает точку, которая находится на середине отрезка
get_begin_point() — принимает на вход отрезок и возвращает точку начала отрезка
get_end_point() — принимает на вход отрезок и возвращает точку конца отрезка
Представление отрезка вы должны придумать сами.

Пример работы:

from points import make_decart_point
 
segment = make_segment(make_decart_point(3, 2), make_decart_point(0, 0))
# В примерах ниже возвращаются точки с координатами (x, y)
get_begin_point(segment)  # {'x': 3, 'y': 2}
get_end_point(segment)  # {'x': 0, 'y': 0}
get_mid_point_of_segment(segment)  # {'x': 1.5, 'y': 1}
Подсказки
Для создания точек используйте функцию make_decart_point()

points

def make_decart_point(x, y):
    return {"x": x, "y": y}

def get_x(point):
    return point["x"]

def get_y(point):
    return point["y"]


**d_polar-decart.py**

В этой задаче тесты написаны для отрезков, которые используют точки. Ваша задача — реализовать интерфейсные функции для работы с точками. Внутреннее представление точек должно быть основано на полярной системе координат, хотя интерфейс предполагает работу с декартовой системой (снаружи).

src/points.py
Реализуйте интерфейсные функции точек:

make_point() — принимает на вход координаты и возвращает точку, уже реализован
get_x()
get_y()
x = 4
y = 8
 
# point хранит в себе данные в полярной системе координат
point = make_point(x, y)
 
# Здесь происходит преобразование из полярной в декартову
get_x(point)  # 4
get_y(point)  # 8
Подсказки
Трансляция декартовых координат в полярные была описана в теории
Получить x можно по формуле radius * cos(angle)
Получить y можно по формуле radius * sin(angle)

import math


def make_point(x, y):
    return {
        "angle": math.atan2(y, x),
        "radius": math.sqrt((x ** 2) + (y ** 2)),
    }


**e_make_rectangle_decart**

Реализуйте абстракцию (набор функций) для работы с прямоугольниками, стороны которого всегда параллельны осям. Прямоугольник может располагаться в любом месте координатной плоскости.

При такой постановке достаточно знать только три параметра для однозначного задания прямоугольника на плоскости: координаты левой-верхней точки, ширину и высоту. Зная их, мы всегда можем построить прямоугольник одним способом.

      Y
      |
    4 |    точка   ширина
      |       *-------------
    3 |       |            |
      |       |            | высота
    2 |       |            |
      |       --------------
    1 |
      |
------|--------------------------- X
    0 |  1   2   3   4   5   6   7
      |
      |
      |
Основной интерфейс:

make_rectangle() (конструктор) — создает прямоугольник. Принимает параметры: левую-верхнюю точку, ширину и высоту. Ширина и высота – положительные числа
Селекторы get_start_point(), get_width() и get_height()
contains_origin() — проверяет, принадлежит ли центр координат прямоугольнику. То есть не лежит на границе прямоугольника, а находится внутри. Чтобы в этом убедиться, достаточно проверить, что все вершины прямоугольника лежат в разных квадрантах. Их можно высчитать в момент проверки
# Создание прямоугольника:
# p - левая верхняя точка
# 4 - ширина
# 5 - высота
#
# p    4
# -----------
# |         |
# |         | 5
# |         |
# -----------
 
p = make_decart_point(0, 1)
rectangle = make_rectangle(p, 4, 5)
 
contains_origin(rectangle)  # False
 
rectangle2 = make_rectangle(make_decart_point(-4, 3), 5, 4)
contains_origin(rectangle2)  # True
Подсказки
Квадрант плоскости — любая из четырех областей или углов, на которые плоскость делится двумя взаимно перпендикулярными прямыми, принятыми в качестве осей координат
Для определения квадранта, в которой лежит точка, используйте функцию get_quadrant():
  point_1 = make_decart_point(2, 3)
  point_2 = make_decart_point(-2, -3)
  get_quadrant(point_1)  # 1
  get_quadrant(point_2)  # 3

def get_quadrant(point):
    x = get_x(point)
    y = get_y(point)

    if x > 0 and y > 0:
        return 1
    if x < 0 < y:
        return 2
    if x < 0 and y < 0:
        return 3
    if y < 0 < x:
        return 4

    return None


**f_make_rational.py**

Реализуйте абстракцию для работы с рациональными числами, которая включает в себя следующие функции:

Конструктор make — принимает на вход числитель и знаменатель, возвращает дробь
Селектор get_numer — возвращает числитель
Селектор get_denom — возвращает знаменатель
Сложение add — складывает переданные дроби
Вычитание sub — находит разность между двумя дробями
Не забудьте реализовать нормализацию дробей удобным для вас способом.

Примеры работы:

import rational
 
rat1 = rational.make(3, 9)
rational.get_numer(rat1)  # 1
rational.get_denom(rat1)  # 3
rat2 = rational.make(10, 3)
rat3 = rational.add(rat1, rat2)
rational.to_str(rat3)  # 11/3
rat4 = rational.sub(rat1, rat2)
rational.to_str(rat4)  # -3/1
Подсказки
Функция gcd из модуля math находит наибольший общий делитель двух чисел
Функция to_str возвращает строковое представление числа (используется для отладки)
Функция int преобразует значение к целому числу

def to_str(rat):
    return f"{get_numer(rat)}/{get_denom(rat)}"


**i_processing_url.py**


Реализуйте абстракцию для работы с URL. Она должна извлекать и менять части адреса.

Интерфейс:

make(url) - Конструктор. Создает URL.
get_scheme(data) - Селектор (геттер). Извлекает схему.
set_scheme(data, scheme) - Сеттер. Меняет схему.
get_host(data) - Геттер. Извлекает host.
set_host(data, host) - Сеттер. Меняет host.
get_path(data) - Геттер. Извлекает путь.
set_path(data, path) - Сеттер. Меняет путь.
get_query_param(data, param_name, default=None) - Геттер. Извлекает значение для параметра запроса. Третьим параметром функция принимает значение по умолчанию, которое возвращается тогда, когда в запросе не было такого параметра
set_query_param(data, key, value) - Сеттер. Устанавливает значение для параметра запроса. Если передано значение None, то параметр отбрасывается.
to_string(data) - Геттер. Преобразует URL в строковой вид.
Все сеттеры должны возвращать новый изменённый URL, а старый оставлять неизменным.

import url
u = url.make('https://hexlet.io/community?q=low')

u = url.set_scheme(u, 'http')
url.to_string(u)  # 'http://hexlet.io/community?q=low'

u = url.set_path(u, '/404')
url.to_string(u)  # 'http://hexlet.io/404?q=low'

url.get_query_param(u, 'q')  # 'low'

u = url.set_query_param(u, 'page', 5)
url.to_string(u)  # 'http://hexlet.io/404?q=low&page=5'

u = url.set_query_param(u, 'q', 'high')
url.to_string(u)  # 'http://hexlet.io/404?q=high&page=5'

u = url.set_query_param(u, 'q', None)
url.to_string(u)  # 'http://hexlet.io/404?page=5'
Подсказки
Парсинг URL — urllib.parse.urlparse
Парсинг параметров запроса — urllib.parse.parse_qs
Формирование строки с параметрами запроса — urllib.parse.urlencode
Сборка конечного URL — urllib.parse.urlunparse
urlparse возвращает иммутабельный объект типа namedtuple. Получить копию такого объекта с одним изменённым значением можно с помощью метода _replace.









